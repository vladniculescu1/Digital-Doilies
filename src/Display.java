import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.ArrayList;
/*
 * this class represents the drawing panel
 * and all of its components
 */
public class Display extends JPanel
{
	Mouse pen = new Mouse();
	Drawing draw = new Drawing();
	boolean showLines = true;	
	private int width;
	private int height;
    
	public Display()
	{
		super();
		this.init();
	}
	
	void init()
	{
		//when we initialise the class, we add the listeners
		this.setBackground(Color.BLACK);
		this.addMouseListener(pen);
	    this.addMouseMotionListener(pen);
	}
	
	
	class Mouse extends MouseAdapter
	{	
		/*
		 * this first method is called whenever the mouse is pressed
		 * at this moment, we need to create an array for storing all the 
		 * points that we will use. we also store various information about the
		 * current set of points so that each line has different properties
		 */
		public void mousePressed(MouseEvent e) 
		{
            draw.points = new ArrayList<>();
            Point startPoint = e.getPoint();
            draw.colours.add(draw.currentColour);
            draw.thickness.add(draw.currentThickness);
            draw.reflections.add(draw.currentReflection);
            startPoint.x -= width/2;  //we need to calibrate the coordinates since we moved the origin of the panel
            startPoint.y -= height/2;
			draw.points.add(startPoint);
            draw.pointList.add(draw.points);
            draw.deleteList.clear();  //when somebody draws again, the undo list is emptied
		}
		
		/*
		 * whenever we drag our mouse after pressing it,
		 * a new point is added to our current line
		 */
		public void mouseDragged(MouseEvent e) 
		{
			Point dragPoint = e.getPoint();
			dragPoint.x -= width/2;
			dragPoint.y -= height/2;
			draw.points.add(dragPoint);
			repaint();
		}

		public void mouseReleased(MouseEvent e)
		{
			draw.points = null;	//after we release the mouse, the "current line" array needs to be emptied again
		}
	}
	
	//this is the method in which all the painting takes place
	public void paintComponent(Graphics g) 
	{
	      super.paintComponent(g);
	      Graphics2D g2D = (Graphics2D) g;//we generate a graphics2D object to allow us to use more methods
	 
	      double secAngle = (double) 360/draw.getNoSec();//this is the angle in radians between each sector line
	      width = getWidth();
	      height = getHeight();
	      g2D.translate(width/2, height/2);//we move the origin of the panel in the centre. This will make drawing easier
	      
	      int j=0;//this variable is used to keep track of all the arrays containing information about the points
	      /*
	       * in the following for loops, we go through each array within our list of arrays
	       * and through each point within those arrays in order to display everything correctly
	       */
	      for (List<Point> path : draw.pointList) 
	      {
	    	  /*
	    	   * in order to achieve smoother lines, we draw lines between each point we draw within an array
	    	   * this covers any missing points generated by random failures of the listeners, since we cannot
	    	   * record every point during a mouse move
	    	   */
	    	  Point from = null;//if the first point is null, this means we move from one line to another
	    	  for (Point p : path)
	    	  {
	    		  g2D.setStroke(new BasicStroke(draw.thickness.get(j), BasicStroke.CAP_ROUND, BasicStroke.JOIN_BEVEL));//this gives the lines a smoother appearance
    			  g2D.setColor(draw.colours.get(j));//we retrieve the line's colour from the colour array
	    		  if (from != null)
	    		  {
	    			  for(int i=0; i<draw.getNoSec(); i++)
	    			  {
	    				  g2D.drawLine(from.x, from.y, p.x, p.y);
	    				  if(draw.reflections.get(j))
	    				  {
	    					  g2D.drawLine(from.x, -from.y, p.x, -p.y);//if the reflection is active, we draw again each line in the reflected space
	    				  }
	    				  /*
	    				   * the following line is used to rotate each line drawn.
	    				   * we rotate the lines in accordance to the number of sectors we have
	    				   * this gives the illusion that all the lines are "reflected" in each sector
	    				   */
	    				  g2D.rotate(Math.toRadians(secAngle));
	    			  }
	    		  }
	    		  /*
	    		   * the following else cover the case of a single point
	    		   * since no line is drawn for a single point, we draw an oval to represent it
	    		   */
	    		  else
	    		  {
	    			  int t = draw.thickness.get(j);
	    			  for(int i=0; i<draw.getNoSec(); i++)
	    			  {
	    				  g2D.fillOval(p.x-t/2, p.y-t/2, t, t);
	    				  if(draw.reflections.get(j))
	    					  g2D.fillOval(p.x-t/2, -p.y-t/2, t, t);
	    				  g2D.rotate(Math.toRadians(secAngle));
	    			  }
	    		  }
	    		  from = p;//after each line is drawn, the end of the line becomes the beginning of the next
	    	  }
	    	  j++;//since we move to another point, we need to make sure that we get the proper information for it
	      }
	      
	      /*
	       * the sector lines are drawn
	       * we draw the sector lines after the drawing lines in order to
	       * keep better track of each sector and make erasing the 
	       * drawn lines easier, without erasing the sector lines
	       */
	      if(showLines)
	      {
	    	  for(int i=0; i<draw.getNoSec(); i++)
	    	  {
	    		  int biggerSize = height;
	    		  if(width>height)
	    			  biggerSize = width;
	    		  g2D.setColor(Color.white);
	    		  g2D.setStroke(new BasicStroke(2));
	    		  g2D.drawLine(0, 0, 0, biggerSize);
	    		  g2D.rotate(Math.toRadians(secAngle));
	    	  }
	      }
	      repaint();//whenever an action occurs, we need to make sure to update our panel
	}
	
	/*
	 * this method is used to save the current drawing in a buffered image
	 * we will use this image for the gallery
	 */
	public BufferedImage screenshot()
	{
		BufferedImage selectedImage;
		selectedImage = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);
		Graphics2D g2D = selectedImage.createGraphics();
		paint(g2D);
		return selectedImage;
	}
}